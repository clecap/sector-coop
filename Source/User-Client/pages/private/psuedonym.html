<!doctype html>
<html>
    <head>
	<title></title>
	<meta charset="utf-8" />
    </head>
    <body>
	<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>       
	<script src="/script/api/userclient.js"></script>
        <!-- <script src="/file/demo-bundle.js"></script> -->
	<script src="https://cdn.jsdelivr.net/npm/web3@1.3.4/dist/web3.min.js"></script>
	<script src="/script/rsablind-bundle.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/socket.io-client@3.1.1/dist/socket.io.min.js"></script>
	<script>
	 //TODO
	</script>
	<!-- <script>
	     var BlindSignature = window.myexports.BlindSignature;
	     var NodeRSA = window.myexports.NodeRSA;
	     
	     var patron1_ethraddress = "0x00000000000000000000000000000000000";
	     var psuedo1_keystore =	{...};
	     if (!confirm("Request for Signature?")){
	     throw new Error("Cannot proceed without user's go.");
	     }
	     const socket = io({auth: {role:"psuedonym",
	     token:"uniquePsuedonymToken",
	     roomCode:"patronRoom"}}); // roomCode must be fetched from patron prior to this connection can proceed.
	     PSUEDONYM_ADDR="0x".concat( psuedo1_keystore.address );
	     const Psuedonym = {
	     message: Web3.utils.hexToBytes(PSUEDONYM_ADDR),
	     N: null,
	     E: null,
	     r: null,
	     signed: null,
	     unblinded: null,
	     };
	     
	     socket.on("disconnect", (reason) => {
	     console.log("Socket Disconnected. Reason: "+reason)
	     });
	     
	     socket.on('patronPubKey', (patronPubKey) => {
	     console.log("Recieved Patron's Public Key");
	     
	     Psuedonym.N = patronPubKey.n;
	     Psuedonym.E = patronPubKey.e;
	     /* console.log(Psuedonym.N.toString()); */
	     // N, E
	     const { blinded, r } = BlindSignature.blindHEX({
	     message: Psuedonym.message,
	     N: Psuedonym.N,
	     E: Psuedonym.E,
	     }); // Psuedonym blinds message
	     Psuedonym.r = r;
	     console.log("Sending Blinded Hash");
	     socket.emit("signingRequest", blinded.toString(16));
	     });

	     socket.on('psuedonymSigningResponse', (blindSignature) => {
	     Psuedonym.signed = blindSignature;
	     console.log("Recieved Blindly signed Signature");
	     const unblinded = BlindSignature.unblindHEX({
	     signed: Psuedonym.signed,
	     N: Psuedonym.N,
	     r: Psuedonym.r,
	     }); // Psuedonym unblinds
	     Psuedonym.unblinded = unblinded;
	     // Psuedonym verifies
	     // N, E
	     /* const result = BlindSignature.verifyHEX({
	     unblinded: Psuedonym.unblinded,
	     N: Psuedonym.N,
	     E: Psuedonym.E,
	     message: Psuedonym.message,
	     }); */

	     // Hex generation and outputs:

	     SMART_CONTRACT_ARGS={PATRON_ADDRESS : patron1_ethraddress,
	     MODULUS_HEX : "0x".concat(Psuedonym.N.toString(16)),
	     EXPONENT_HEX : "0x".concat(Psuedonym.E.toString(16)),
	     SIGNATURE_UNBLINDED_HEX : "0x".concat(Psuedonym.unblinded.toString(16)),
	     MESSAGE_PLAIN : Psuedonym.message };
	     </script> -->
    </body>
</html>
